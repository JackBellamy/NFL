#imports
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
import math
data_plays = pd.read_csv("~/Desktop/NFL/Data/plays.csv")
data_tracking2018 = pd.read_csv("~/Desktop/NFL/Data/tracking2018.csv")
data_tracking2019 = pd.read_csv("~/Desktop/NFL/Data/tracking2019.csv")
data_tracking2020 = pd.read_csv("~/Desktop/NFL/Data/tracking2020.csv")
data = np.load("/Users/TobyCheng/Desktop/NFL/Arrays/data_running.npy", allow_pickle = True)

#%%
import matplotlib as mpl
import matplotlib.font_manager as font_manager
plt.style.use('default')
mpl.rcParams['font.family']='serif'
cmfont = font_manager.FontProperties(fname=mpl.get_data_path() + '/fonts/ttf/cmr10.ttf')
mpl.rcParams['font.serif']=cmfont.get_name()
mpl.rcParams['mathtext.fontset']='cm'
mpl.rcParams['axes.unicode_minus']=False


#%% return values based on conditions
def return_vals(data, condition_name, comparison, condition_answer, return_collumn):
    conditions = ""
    for i in range(0, len(condition_name)-1):
        cn = condition_name[i]
        c = comparison[i]
        ca = condition_answer[i]
        if type(ca) is str:
            conditions += cn+" "+c+" "+"\""+ca+"\""+" "+"&"+" "
        else:
            ca = str(ca)
            conditions += cn+" "+c+" "+ca+" "+"&"+" "
    cn = condition_name[-1]
    c = comparison[-1]
    ca = condition_answer[-1]
    if type(ca) is str:
        conditions += cn+" "+c+" "+"\""+ca+"\""
    else:
        ca = str(ca)
        conditions += cn+" "+c+" "+ca
    conditions = str(conditions)
    return data.query(conditions)[return_collumn]



#%% k = k nearest players
def field_control_average(gameId, playId, frame_start, frame_end, k, top_speed, reaction_time):
    if str(gameId)[:4] == "2018":
        data_tracking = data_tracking2018
    elif str(gameId)[:4] == "2019":
        data_tracking = data_tracking2019
    elif str(gameId)[:4] == "2020":
        data_tracking = data_tracking2020
        
    ca = ["gameId", "playId", "team"]
    c = ["==", "==", "=="]
    cn_home = [gameId, playId, "home"]
    cn_away = [gameId, playId, "away"]
    
    x_home = (np.array(return_vals(data_tracking, ca, c, cn_home, "x")))
    y_home = np.array(return_vals(data_tracking, ca, c, cn_home, "y"))
    x_away = (np.array(return_vals(data_tracking, ca, c, cn_away, "x")))
    y_away = np.array(return_vals(data_tracking, ca, c, cn_away, "y"))
    s_home = (np.array(return_vals(data_tracking, ca, c, cn_home, "s")))
    s_away = np.array(return_vals(data_tracking, ca, c, cn_away, "s"))    
    d_home = (np.array(return_vals(data_tracking, ca, c, cn_home, "dir")))
    d_away = np.array(return_vals(data_tracking, ca, c, cn_away, "dir"))
    
    x_home = x_home.reshape(11, int(len(x_home)/11))
    y_home = y_home.reshape(11, int(len(y_home)/11))
    x_away = x_away.reshape(11, int(len(x_away)/11))
    y_away = y_away.reshape(11, int(len(y_away)/11))
    s_home = s_home.reshape(11, int(len(s_home)/11))
    s_away = s_away.reshape(11, int(len(s_away)/11))
    d_home = d_home.reshape(11, int(len(d_home)/11))
    d_away = d_away.reshape(11, int(len(d_away)/11))
    
    field_control_all = []
    for n in range(frame_start, frame_end+1):
        x_h = []
        y_h = []
        d_h = []
        s_h = []
        for i in range(0, 11):
            x_val_h = (x_home[i])[n]
            x_h.append(x_val_h)
            y_val_h = (y_home[i])[n]
            y_h.append(y_val_h)
            d_val_h = (d_home[i])[n]
            d_h.append(d_val_h)
            s_val_h = (s_home[i])[n]
            s_h.append(s_val_h)
            
        x_a = []
        y_a = []
        d_a = []
        s_a = []
        for i in range(0, 11):
            x_val_a = (x_away[i])[n]
            x_a.append(x_val_a)
            y_val_a = (y_away[i])[n]
            y_a.append(y_val_a)
            d_val_a = (d_away[i])[n]
            d_a.append(d_val_a)
            s_val_a = (s_away[i])[n]
            s_a.append(s_val_a)

     
        field_control_frame = np.zeros([53, 120])
        for x in range(0, 120):
            for y in range(0, 53):
                t_h = []
                t_a = []
                for i in range(0, 11):
                    is_h = s_h[i]
                    id_h = d_h[i]
                    ix_h = x_h[i]
                    iy_h = y_h[i] 
                    
                    ivx_h = is_h * math.cos(math.pi/2)-math.radians(id_h)
                    ivy_h = is_h * math.sin(math.pi/2)-math.radians(id_h)
                    after_reaction_x_h = reaction_time * ivx_h
                    after_reaction_y_h = reaction_time * ivy_h
                    
                    distance_x_h = abs((ix_h + after_reaction_x_h) - x)
                    distance_y_h = abs((iy_h + after_reaction_y_h) - y)
                    distance_h = math.sqrt((distance_x_h ** 2)+(distance_y_h ** 2))
                    
                    t_h.append(distance_h/top_speed)

                    
                    is_a = s_a[i]
                    id_a = d_a[i]
                    ix_a = x_a[i]
                    iy_a = y_a[i] 
                    
                    ivx_a = is_a * math.cos(math.pi/2)-math.radians(id_a)
                    ivy_a = is_a * math.sin(math.pi/2)-math.radians(id_a)
                    
                    after_reaction_x_a = reaction_time * ivx_a
                    after_reaction_y_a = reaction_time * ivy_a
                    
                    distance_x_a = abs((ix_a + after_reaction_x_a) - x)
                    distance_y_a = abs((iy_a + after_reaction_y_a) - y)
                    distance_a = math.sqrt((distance_x_a ** 2)+(distance_y_a ** 2))
                    
                    t_a.append(distance_a/top_speed) 

                    
                t_h = sorted(set(t_h))[:k]
                t_a = sorted(set(t_a))[:k]
                th = sum(t_h)
                ta = sum(t_a)


                field_control_frame[y,x] = 1/(1+math.e ** (th-ta))
        field_control_all.append(field_control_frame)
    
    values = np.zeros([53,120])
    for x in range(0, 120):
        for y in range(0, 53):
            fc_vals = []
            for i in range(0, len(field_control_all)):
                fc_vals.append(((field_control_all[i])[y])[x])
            values[y,x] = (sum(fc_vals)/len(fc_vals))
    return values



#%%
def split_data(yardage_criteria):
    data_good = np.zeros([1, 10])
    data_nogood = np.zeros([1, 10])
    for n in range(0, np.shape(data)[0]):
        yardsGained = int(data[n, 3])
        if yardsGained > yardage_criteria:
            data_good = np.vstack([data_good, data[n, :]])
        else:
            data_nogood = np.vstack([data_nogood, data[n, :]])
    data_good = np.delete(data_good, 0, 0)
    data_nogood = np.delete(data_nogood, 0, 0)
    return data_good, data_nogood

data_good, data_nogood = split_data(3)

#%% dt = frame differences for avg, lx, ... uy, .. = cropping around normalization

def return_normalized_values(data_group, dt1, dt2, k, top_speed, reaction_time):
    values = []
    for n in range(0, np.shape(data_group)[0]):
        print(n)
        gid = int(data_group[n, 0])
        pid = int(data_group[n, 1])
        frame_start = int(data_group[n, 8])
        play_direction = data_group[n, 7]
        possession_team = data_group[n, 9]
        y_pos = int(data_group[n, 6])
        value = field_control_average(gid, pid, frame_start+dt1, frame_start+dt2, k, top_speed, reaction_time)
        if play_direction == "left":
            if possession_team == "home":
                values.append(np.rot90(value, 2))
            elif possession_team == "away":
                value_flipped = np.zeros([53, 120])
                for x in range(0, 120):
                    for y in range(0, 53):
                        val = value[y,x]
                        value_flipped[y,x] = 1-val
                values.append(np.rot90(value_flipped, 2))
        elif play_direction == "right":
            if possession_team == "home":
                values.append(value)
            elif possession_team == "away":
                value_flipped = np.zeros([53, 120])
                for x in range(0, 120):
                    for y in range(0, 53):
                        val = value[y,x]
                        value_flipped[y,x] = 1-val
                values.append(value_flipped)
    return values
 

norm_values_good = return_normalized_values(data_good, 0, 0, 1, 8, 1)
norm_values_nogood = return_normalized_values(data_nogood, 0, 0, 1, 8, 1)


#%%


def plot_optimal_vs_actual(i, frame, attempt_touchdown, data_good):
    #setup
    gid = int(data_good[i, 0])
    pid = int(data_good[i, 1])
    print(gid, pid)
    play_direction = data_good[i, 7]

    
    #calculate the actual path
    cn = ["gameId", "playId", "team"]
    c = ["==", "==", "=="]
    ca = [gid, pid, "football"]
    if str(gid)[:4] == "2018":
        xball = (return_vals(data_tracking2018, cn, c, ca, 'x')).tolist()
        yball = (return_vals(data_tracking2018, cn, c, ca, 'y')).tolist()
    elif str(gid)[:4] == "2019":
        xball = (return_vals(data_tracking2019, cn, c, ca, 'x')).tolist()
        yball = (return_vals(data_tracking2019, cn, c, ca, 'y')).tolist()
    elif str(gid)[:4] == "2020":
        xball = (return_vals(data_tracking2020, cn, c, ca, 'x')).tolist()
        yball = (return_vals(data_tracking2020, cn, c, ca, 'y')).tolist()

    

    if play_direction == "left":
        x_ball = []
        y_ball = []
        for j in range(0, len(xball)):
            x_ball.append(120 - xball[j])
            y_ball.append(53.3 - yball[j])
    else:
        x_ball = xball
        y_ball = yball

            
    #normalize (max energy on RHS)
    x_pos = round(x_ball[frame])
    y_pos = round(y_ball[frame])
    value = norm_values_good[i]
    s1 = np.zeros([53, 120])
    for x in range(0, 120):
        for y in range(0, 53):
            val = value[y,x]
            s1[y,x] = 1-val
    vals = []
    counter = 0
    s2 = np.zeros([53, 120])
    
    #calculate cumulative energy
    for x_inv in range(0, 120):
        x = 120 - x_inv - 1
        if x == x_pos:
            break
        elif x == 119:
            for y in range(0, 52):
                s2[y,x] = s1[y,x]
        else:
            for y in range(0, 52):
                if y == 0:
                    value_right_middle = s2[y, x+1]
                    value_right_down = s2[y+1, x+1]
                    options = [value_right_middle, value_right_down]
                    s2[y, x] = (min(options) + s1[y, x])
                elif y == 52:
                    value_right_middle = s2[y, x+1]
                    value_right_up = s2[y-1, x+1]
                    options = [value_right_middle, value_right_up]
                    s2[y, x] = (min(options) + s1[y, x])
                else:
                    counter += 1
                    value_right_down = s2[y-1, x+1]
                    value_right_middle = s2[y, x+1]
                    value_right_up = s2[y-1, x+1]
                    options = [value_right_up, value_right_middle, value_right_down]
                    s2[y, x] = (min(options) + s1[y, x])
    
    #find optimal path (alpha = preference to head straight instead of L/R)
    y2g = int(return_vals(data_plays, ["gameId", "playId"], ["==", "=="], [gid, pid], "yardsToGo"))
    if attempt_touchdown == False:
        xtarget = round(x_ball[0]) + y2g
    else:
        xtarget = 119
    
    pathx = []
    pathy = []
    alpha = 1
    for x in range(x_pos, xtarget):
        if x == x_pos:
            pathx.append(x)
            pathy.append(y_pos)
        else:
            pathx.append(x)
            y = pathy[-1]
            if y <= 1:
                right_y_middle = (s2[y, x+1])*alpha
                right_y_down = s2[y+1, x+1]
                options = [right_y_middle, right_y_down]
                choice = options.index(min(options))
                if choice == 0:
                    pathy.append(y)
                elif choice == 1:
                    pathy.append(y+1)
            elif y == 52:
                right_y_up = s2[y-1, x+1]
                right_y_middle = s2[y, x+1]*alpha
                options = [right_y_up, right_y_middle]
                choice = options.index(min(options))
                if choice == 0:
                    pathy.append(y-1)
                elif choice == 1:
                    pathy.append(y)
            else:
                right_y_up = s2[y-1, x+1]
                right_y_middle = s2[y, x+1]*alpha
                right_y_down = s2[y+1, x+1]
                options = [right_y_up, right_y_middle, right_y_down]
                choice = options.index(min(options))
                if choice == 0:
                    pathy.append(y-1)
                elif choice == 1:
                    pathy.append(y)
                elif choice == 2:
                    pathy.append(y+1)
                    
    path_energy = []
    for i in range(0, len(pathx)):
        path_energy.append(s1[pathy[i],pathx[i]])
        
    return pathx, pathy, s2, x_ball, y_ball, y2g, path_energy


#%%VIEWING ANY GAME ID OR PLAY ID USING i AND CAN CHOOSE ANY FRAME IN THE FUNCTION
from mpl_toolkits.axes_grid1 import make_axes_locatable
cmap = mpl.cm.get_cmap('binary')
pathx, pathy, s2, xb, yb, y2g, pe = plot_optimal_vs_actual(15, 20, True, data_good)
x_pos = pathx[0]
y_pos = pathy[0]
fig, axs = plt.subplots(1, 1,figsize=(15, 15))
axs.axvline(x_pos + 5.1, color = "grey", label = "LOS", lw = 1, ls = "--")
axs.axvline(x_pos + 5.1 + y2g , color = "blue", label = "First Down", lw = 2)
axs.plot(pathx[:10], pathy[:10], color = "white", lw = 14, alpha = 0.5)
axs.plot(pathx, pathy, color = "purple", label = "Optimal Path", lw = 5)
im = axs.imshow(s2, cmap = "binary")
axs.plot(xb[20:], yb[20:], color = "orange", label = "Actual Path Taken", lw = 5)
axs.axvspan(0, 40, color = cmap(0.95))
axs.set_xlim([0, 120])
axs.set_ylim([51, 0])
axs.set_xticks([0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])
axs.set_xticklabels([0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120], fontsize = 20)
axs.set_yticks([51, 41, 31, 21, 11, 1])
axs.set_yticklabels([0, 10, 20, 30, 40, 50], fontsize = 20)
axs.legend(fontsize = 20, loc = "upper left")
axs.set_xlabel(r"$x$", fontsize = 26)
axs.set_ylabel(r"$y$", fontsize = 26)
axs.set_box_aspect(51/120)

#%%
energy = pe[:10]
print(sum(energy)/len(energy))

print((11/(11+6)*100))
print((20/(20+9)*100))

yes = 20
no = 9
